# Task 1.2: Create CatalogLoader

## Status: [ ] Not Started

## ⚠️ AWARENESS: Codice Esistente!
**LEGGI PRIMA**: `docs/TASKS/CONTEXT.md`
**Esiste già**: `src/data_manager/catalog.py` (736 linee, CopernicusCatalog)

## Goal
Bridge tra Intake YAML e CopernicusCatalog esistente (NON riscrivere!).

## Output File
`src/data_manager/intake_bridge.py` (NOME DIVERSO per non sovrascrivere!)

## Dependencies
- Task 1.1 completed
- **USA**: `src/data_manager/catalog.py` esistente

## Code

```python
"""IntakeBridge - Collega Intake YAML al CopernicusCatalog esistente."""
import intake
from pathlib import Path
from typing import List, Dict, Any
import xarray as xr

from src.data_manager.catalog import CopernicusCatalog  # ✅ USA ESISTENTE

ROOT = Path(__file__).parent.parent.parent
CATALOG_PATH = ROOT / "catalog.yaml"


class IntakeCatalogBridge:
    """
    Bridge pattern: Intake YAML come index, 
    CopernicusCatalog esistente per Copernicus,
    client specifici per altri (ERA5, CYGNSS).
    """
    
    def __init__(self, catalog_path: Path = CATALOG_PATH):
        self.intake_cat = intake.open_catalog(str(catalog_path))
        self.copernicus_cat = CopernicusCatalog()  # ✅ Riusa!
    
    def list_datasets(self) -> List[str]:
        return list(self.intake_cat)
    
    def get_metadata(self, dataset_id: str) -> Dict[str, Any]:
        return dict(self.intake_cat[dataset_id].metadata)
    
    def search(
        self,
        variables: List[str] = None,
        latency_badge: str = None,
        status: str = "available",
    ) -> List[str]:
        results = []
        for name in self.intake_cat:
            meta = self.get_metadata(name)
            if meta.get("status") != status:
                continue
            if latency_badge and meta.get("latency_badge") != latency_badge:
                continue
            if variables:
                ds_vars = meta.get("variables", [])
                if not any(v in ds_vars for v in variables):
                    continue
            results.append(name)
        return results
    
    async def load(self, dataset_id: str, **kwargs) -> xr.Dataset:
        """Carica usando il provider appropriato."""
        meta = self.get_metadata(dataset_id)
        provider = meta.get("provider", "").lower()
        
        if "copernicus" in provider or "cmems" in provider:
            # Usa CopernicusCatalog esistente
            return await self.copernicus_cat.download_data(
                product_id=meta.get("product_id"),
                **kwargs
            )
        else:
            # Fallback a Intake diretto
            return self.intake_cat[dataset_id].to_dask()


_bridge = None

def get_catalog() -> IntakeCatalogBridge:
    global _bridge
    if _bridge is None:
        _bridge = IntakeCatalogBridge()
    return _bridge
```

## Test Command
```bash
source .venv/bin/activate
python -c "from src.data_manager.catalog_loader import get_catalog; c = get_catalog(); print(c.list_datasets())"
```

## Done Criteria
- [ ] File exists at `src/data_manager/catalog_loader.py`
- [ ] `get_catalog().list_datasets()` returns dataset names
- [ ] `get_catalog().search(status='available')` filters correctly

## Next Task
→ 1.3_catalog_api.md
